---
title: "DCF Topics"
author: "Daniel Kaplan"
date: "April 23, 2014"
output: html_document
---

```{r include=FALSE}
require(dplyr)
```

See also : `DCF-2014/Narrative/Overall_Outline.Rmd`  Consolidate that file into this one.

Also `Narrative/Ideas.Rmd`.

Also `Sections/Introduction/Overview.Rmd`

## Data Organization

1) Cases and variables

Call it a **datatable**: one word to give it a technical meaning, restricted to a rigid format.

Rows and columns

Quantitative and categorical

There are other forms of data, e.g. photographs, movies, text.  The datatable is arguably the most important.  Many other forms of data eventually get reduced to datatables for the purposes of display and analysis.

Emphasis the **case**.

* How the meaning of an individual case can change.  A datatable gives a **view of data**.  There are typically other views possible, sometimes derived from a particular view.

Runners as individuals and as groups, e.g. by sex, by age group, by sex and age group.

Flight data involving two airports compared to airport data (e.g. latitude and longitude) on its own.  Taxi time versus airport.  Airplane model data: mass and engines

### Wide and narrow: 

What's a case and what's a variable is somewhat fluid.

* Individual runners in multiple years: wide and narrow
* 96-well plate and spectrophotometer
* UN data where the case is a country and where the case is a country in a year and where the case is a particular measurement in a country in a year

It's not that one form is right and the others are wrong.  Some forms are better for a particular purpose, e.g. making a scatterplot of year-2 versus year-1 is easily handled with wide data.

**Shaping** data means transcribing data from one datatable form to another. (It doesn't mean distorting data or altering or redacting).

Many of the techniques for working with data are about shaping it, so that you can present it in the way that you think best rather than in the ways that happen to match the original shapes.

**Database** is a collection of datatables.  Often, the datatables have different cases.

### Reading and Storing Data

Various common formats: CSV, XLSX

Informal formats (e.g. the Cherry Blossom race) for human consumption. 

Different ways data are distributed: interactive, static files, via URL 

Data Scraping

## Graphics


[Graphics Zoo](GraphicsZoo/GraphicsZoo.html)


Why is a picture worth a thousand words? 

What are the basic features we want to display? Comparison, extent, individual cases in context, relationships, connections, ...

### One Case at a Time: **Individuals**

1) Scatterplot
#) Dotplot
#) Box-and-whiskers plot
#) Barplot
    a) stacked
#) Parallel Axes


### Two Cases at a Time: **Connections**

1) Graph
    [A blog tutorial on igraph](http://www.r-bloggers.com/network-visualization-in-r-with-the-igraph-package/) shows how to set colors, etc.  [A more detailed tutorial](http://www.lsi.upc.edu/~CSN/lab/session1.pdf)
    a) Directed
    #) Undirected
#) Tree

### Many Cases at a Time: **Collectives**

1) density
#) histogram
#) hexbin

## Developing Data

It's convenient when data come to you in glyph-ready form.  But often, the data you have with are not exactly what you need.  They contain information of interest, but not in a form that's ready for presentation.  The process of putting your data into the right form for your purpose is called **data wrangling**.  This differs from **data collection** or **data acquisition**.  In wrangling, you're not recording new information but re-arranging or transforming existing information to a more helpful form.  

The word "wrangling" is motivated by the image of cowboys at work.  Cowboys round up cattle, go after strays, and generally put the cattle in good order for the purpose at hand, whether that be leading the cattle up to a spring meadow, moving them to market, or preparing them for feeding.  You won't be feeding your data, but after you've spent some time with them, you'll get the sense that data need care: curating.

Wrangling data takes thought.  Usually, it's not that hard to sketch out the final form you imagine you need (e.g. the glyph-ready form).  Computers provide the operations and effort needed, but you need to know how to use and sequence those operations.

This section describes a small set of operations that are useful for wrangling.  The individual operations are simple.  Yet they can be combined in an infinite variety of ways.  You have to find the combination and sequence that leads you from the form of data you have to the form required for the presentation you want to make.

It's worthwhile to memorize the set of operations, even before you know what they do.  The names used here will are chosen to make it easy to remember the R functions that you will use in these notes. (Aside: Reference and describe Hadley Wickham's `dplyr` package.) Other computer systems use different names, but the concepts remain the same.

* Summarize
* Group
* Filter
* Mutate
* Select
* Join

[[Note in DRAFT: I'm leaving out `arrange()`.  What others??]]

Notice that these are all verbs.  Using these operations, you're going to be doing things to data tables.  Each of these operations will take an input and produce an output.  The input will always be one (or more) data tables along with details of the operation. The output will always be a data table, usually one that has different cases or variables than the input.

### Group and Summarize

In general, a summary is a concise description that leaves out details that are not central.  The summarize operation on data tables works along these lines these lines but is very much more specific.  Whereas a data table in general can have many cases and variables, the output from summarizing is a data table with **only one row per group**.  You get to choose what aspects of the input data table you put in that single row.

To illustrate, consider the Galton data on the heights of parents and their adult children:
```{r}
str(mosaic::Galton)
```

The `summarize()` function reduces all the cases in a group to a single case that contains the quantities you specify.

```{r}
summarize( mosaic::Galton, mKid=mean(height)  )
```

Unless you specify differently, a data table has only one group.  You can change this with the `groupBy()` function.  Here, for instance, the Galton data is broken down into two groups, one for each sex.

```{r}
GaltonBySex <- group_by( mosaic::Galton, sex )
```

`Summarize()` recognizes the grouping and does what you would expect:
```{r}
summarize( GaltonBySex, mKid=mean(height)  )
```


You can calculate more than one thing in the same operation, but always the output will have just one case for each input group.

```{r}
summarize( GaltonBySex, mKid=mean(height), mMother=mean(mother)  )
```

#### EXERCISES

Give a `summary()` of a data frame.  Ask how many distinct groups will be produced by
* `group_by( data, onevar)`
* `group_by( data, first, second)`

Galton: ask to group by family and find the standard deviation of father, mother, and nkids.  Then filter to see if there are any mistakes.  GENERALLY, use filter to pull out cases not in a set of standard cases.



#### Technical stuff

Count with `n()`

ASIDE: Chaining with `%.%`

Naming the grouping variables

Using `ntiles()` on a categorical variable.

TIP:  Don't confuse the `summarize()` function with other tools such as `str()` for presenting data in short form.  For instance, the `summary()` function gives a quick overview of a data table, e.g.
```{r}
summary(mosaic::Galton)
```
`Summary()` and `summarize()` have little in common except the first six letters of their names.

## Data Table Operations

1) Select variables  (Relational PROJECT)
#) Filter  (RELATIONAL SELECT)
    a) head, tail --- to pull out the early ones
#) Mutate
    a) conditional choice
#) Group  (RELATIONAL GROUP)
    a) tally
        * Minneapolis Mayor's race.  Do a simple tally and ask "Who won?"  Actually the law requires ... and move on to `removeOne()`.
        * Refactor Galton to have information for each family: father, mother, nkids.  Then, for the height data: sex, height, family.  In your example, say that Galton has already been joined with family.
#) Arrange (RELATIONAL SORT)
#) Join (RELATIONAL JOIN)
    a) inner
    b) left
    c) semi
    d) anti
    
    
## Dimension Reduction

1) Clustering
#) Principal components

## Modeling

1) Linear
#) Smoother
#) Classification Tree

